<!doctype html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <title>Triangulacja z wizualizacją</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
        max-width: 600px;
        margin: auto;
      }
      label {
        display: block;
        margin-top: 10px;
      }
      input[type="number"] {
        width: 100%;
        padding: 5px;
        margin-top: 5px;
      }
      button {
        margin-top: 15px;
        padding: 10px;
        width: 100%;
      }
      #wynik {
        margin-top: 20px;
        font-weight: bold;
      }
      #canvasContainer {
        text-align: center;
        margin-top: 30px;
      }
      canvas {
        border: 1px solid #ccc;
        background: #f9f9f9;
      }
    </style>
  </head>
  <body>
    <h1>Triangulacja z wizualizacją</h1>
    <p>Wpisz dane i zobacz położenie punktu C oraz kąty.</p>

    <form id="triangulacjaForm">
      <label>
        Odległość AB (m):
        <input
          type="number"
          id="odlegloscAB"
          value="1000"
          min="0"
          step="any"
          required
        />
      </label>

      <label>
        Kąt α przy punkcie A (stopnie):
        <input
          type="number"
          id="katAlfa"
          value="30"
          min="0"
          max="180"
          step="any"
          required
        />
      </label>

      <label>
        Kąt β przy punkcie B (stopnie):
        <input
          type="number"
          id="katBeta"
          value="45"
          min="0"
          max="180"
          step="any"
          required
        />
      </label>
    </form>

    <div id="wynik"></div>

    <div id="canvasContainer">
      <canvas id="canvas" width="500" height="400"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      function triangulacja(c, alfaDeg, betaDeg) {
        const alfa = (alfaDeg * Math.PI) / 180;
        const beta = (betaDeg * Math.PI) / 180;
        const gamma = Math.PI - alfa - beta;

        if (gamma <= 0) return null;

        const a = (c * Math.sin(alfa)) / Math.sin(gamma); // BC
        const b = (c * Math.sin(beta)) / Math.sin(gamma); // AC

        const xC = b * Math.cos(alfa);
        const yC = b * Math.sin(alfa);

        return { x: xC, y: yC, a, b, alfa, beta, gamma };
      }

      function drawScene(c, alfaDeg, betaDeg, pointC) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Ustawienia skalowania i marginesy
        const margin = 50;
        // Skalujemy odległości, żeby mieściły się na canvasie
        const scale = Math.min(
          (canvas.width - 2 * margin) / c,
          (canvas.height - 2 * margin) / c,
        );

        // Punkty w układzie canvas (y odwrócone)
        const A = { x: margin, y: canvas.height - margin };
        const B = { x: margin + c * scale, y: canvas.height - margin };
        const C = {
          x: margin + pointC.x * scale,
          y: canvas.height - margin - pointC.y * scale,
        };

        // Funkcja rysująca punkt
        function drawPoint(pt, label) {
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 6, 0, 2 * Math.PI);
          ctx.fillStyle = "blue";
          ctx.fill();
          ctx.font = "16px Arial";
          ctx.fillStyle = "black";
          ctx.fillText(label, pt.x + 8, pt.y - 8);
        }

        // Funkcja rysująca linię
        function drawLine(p1, p2, color = "black") {
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        // Funkcja rysująca łuk kąta
        function drawAngleArc(
          center,
          startAngle,
          endAngle,
          radius,
          color = "red",
        ) {
          ctx.beginPath();
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.arc(center.x, center.y, radius, startAngle, endAngle);
          ctx.stroke();
        }

        // Rysujemy trójkąt ABC
        drawLine(A, B);
        drawLine(A, C);
        drawLine(B, C);

        // Rysujemy punkty A, B, C
        drawPoint(A, "A");
        drawPoint(B, "B");
        drawPoint(C, "C");

        // Rysujemy kąty α i β jako łuki i opisy

        // Kąt α przy A (między AB i AC)
        // AB leży na osi X w prawo, czyli od 0 radianów,
        // AC ma kąt alfa w radianach względem AB
        const arcRadius = 30;
        drawAngleArc(A, 0, pointC.alfa, arcRadius);
        currentState.A = A;
        currentState.B = B;
        currentState.C = C;
        currentState.scale = scale;
        currentState.margin = margin;

        ctx.fillStyle = "red";
        ctx.font = "18px Arial";
        ctx.fillText("α", A.x + arcRadius + 5, A.y - 5);

        // Kąt β przy B (między BA i BC)
        // BA jest od B do A: na osi X w lewo, czyli kąt π,
        // BC ma kąt beta od BA, więc łuk od π do π - beta (odwrotnie, bo y odwrócone)
        // Trzeba uwzględnić, że na canvasie oś Y jest "do góry" - y maleje w górę

        // Kąt β rysujemy od π do π - beta (czyli na lewo od osi X)
        // Ale ponieważ y jest odwrócone w canvasie, trzeba zmienić kierunek łuku

        // Obliczamy start i end dla łuku kąta β przy B:
        const betaStart = Math.PI;
        const betaEnd = Math.PI - pointC.beta;

        drawAngleArc(B, betaEnd, betaStart, arcRadius);
        ctx.fillText("β", B.x - arcRadius - 20, B.y - 5);
      }

      // Rysujemy scenę przy pierwszym ładowaniu z domyślnymi wartościami
      window.onload = () => {
        const c = parseFloat(document.getElementById("odlegloscAB").value);
        const alfa = parseFloat(document.getElementById("katAlfa").value);
        const beta = parseFloat(document.getElementById("katBeta").value);
        const wynik = triangulacja(c, alfa, beta);
        if (wynik) {
          drawScene(c, alfa, beta, wynik);
          const wynikDiv = document.getElementById("wynik");
          wynikDiv.innerHTML = `
  <div>Odległość AC: <strong>${wynik.b.toFixed(2)} m</strong></div>
  <div>Odległość BC: <strong>${wynik.a.toFixed(2)} m</strong></div>
`;
        }
      };

      const inputs = ["odlegloscAB", "katAlfa", "katBeta"].map((id) =>
        document.getElementById(id),
      );

      inputs.forEach((input) => {
        input.addEventListener("input", () => {
          const c = parseFloat(document.getElementById("odlegloscAB").value);
          const alfa = parseFloat(document.getElementById("katAlfa").value);
          const beta = parseFloat(document.getElementById("katBeta").value);

          // Walidacja — nie pozwól na NaN
          if (isNaN(c) || isNaN(alfa) || isNaN(beta)) return;

          const wynik = triangulacja(c, alfa, beta);
          const wynikDiv = document.getElementById("wynik");

          if (!wynik) {
            wynikDiv.textContent =
              "Błędne kąty! Suma α i β musi być mniejsza niż 180°.";
            ctx.clearRect(0, 0, canvas.width, canvas.height);
          } else {
            wynikDiv.innerHTML = `
  <div>Odległość AC: <strong>${wynik.b.toFixed(2)} m</strong></div>
  <div>Odległość BC: <strong>${wynik.a.toFixed(2)} m</strong></div>
`;
            drawScene(c, alfa, beta, wynik);
          }
        });
      });

      let dragging = false;
      let draggedPoint = null;
      let currentState = {
        A: { x: 0, y: 0 },
        B: { x: 0, y: 0 },
        C: { x: 0, y: 0 },
        scale: 1,
        margin: 50,
      };

      function screenToWorld(x, y) {
        return {
          x: (x - currentState.margin) / currentState.scale,
          y: (canvas.height - currentState.margin - y) / currentState.scale,
        };
      }

      canvas.addEventListener("mousedown", (e) => {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        const dist = (p) => Math.hypot(p.x - mx, p.y - my);

        if (dist(currentState.C) < 10) {
          dragging = true;
          draggedPoint = "C";
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (!dragging) return;

        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        if (draggedPoint === "C") {
          // Przelicz C w układzie rzeczywistym (metry)
          const world = screenToWorld(mx, my);
          const Cx = world.x;
          const Cy = world.y;

          const A = { x: 0, y: 0 };
          const B = {
            x: parseFloat(document.getElementById("odlegloscAB").value) || 1000,
            y: 0,
          };

          const a = Math.hypot(B.x - Cx, B.y - Cy); // BC
          const b = Math.hypot(Cx - A.x, Cy - A.y); // AC
          const c = B.x - A.x;

          const alfa = Math.acos((b ** 2 + c ** 2 - a ** 2) / (2 * b * c));
          const beta = Math.acos((a ** 2 + c ** 2 - b ** 2) / (2 * a * c));

          const alfaDeg = (alfa * 180) / Math.PI;
          const betaDeg = (beta * 180) / Math.PI;

          // Ustaw wartości inputów
          document.getElementById("katAlfa").value = alfaDeg.toFixed(2);
          document.getElementById("katBeta").value = betaDeg.toFixed(2);

          // Ponowne przeliczenie i rysowanie
          const wynik = triangulacja(c, alfaDeg, betaDeg);
          if (wynik) {
            document.getElementById("wynik").innerHTML = `
        <div>Odległość AC: <strong>${wynik.b.toFixed(2)} m</strong></div>
        <div>Odległość BC: <strong>${wynik.a.toFixed(2)} m</strong></div>
      `;
            drawScene(c, alfaDeg, betaDeg, wynik);
          }
        }
      });

      canvas.addEventListener("mouseup", () => {
        dragging = false;
        draggedPoint = null;
      });
    </script>
  </body>
</html>
